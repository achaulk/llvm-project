// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPILE_COMPILER_H_
#define FLATBUFFERS_GENERATED_COMPILE_COMPILER_H_

#include "flatbuffers/flatbuffers.h"

namespace compiler {

struct FileContents;
struct FileContentsBuilder;

struct OpenRequest;
struct OpenRequestBuilder;

struct OpenResponse;
struct OpenResponseBuilder;

struct StatRequest;
struct StatRequestBuilder;

struct StatResponse;
struct StatResponseBuilder;

struct CompileSourceFile;
struct CompileSourceFileBuilder;

struct CompileRequest;
struct CompileRequestBuilder;

struct CompileStatus;
struct CompileStatusBuilder;

struct Exit;
struct ExitBuilder;

struct CompilerInfo;
struct CompilerInfoBuilder;

struct CompilerMessage;
struct CompilerMessageBuilder;

struct HostMessage;
struct HostMessageBuilder;

enum FileError : uint16_t {
  FileError_None = 0,
  FileError_AccessViolation = 1,
  FileError_NotExist = 2,
  FileError_MIN = FileError_None,
  FileError_MAX = FileError_NotExist
};

inline const FileError (&EnumValuesFileError())[3] {
  static const FileError values[] = {
    FileError_None,
    FileError_AccessViolation,
    FileError_NotExist
  };
  return values;
}

inline const char * const *EnumNamesFileError() {
  static const char * const names[4] = {
    "None",
    "AccessViolation",
    "NotExist",
    nullptr
  };
  return names;
}

inline const char *EnumNameFileError(FileError e) {
  if (flatbuffers::IsOutRange(e, FileError_None, FileError_NotExist)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFileError()[index];
}

enum CompileMode : uint16_t {
  CompileMode_CompileToObj = 0,
  CompileMode_CompileAndLink = 1,
  CompileMode_Preprocess = 2,
  CompileMode_CompileToAssembly = 3,
  CompileMode_MIN = CompileMode_CompileToObj,
  CompileMode_MAX = CompileMode_CompileToAssembly
};

inline const CompileMode (&EnumValuesCompileMode())[4] {
  static const CompileMode values[] = {
    CompileMode_CompileToObj,
    CompileMode_CompileAndLink,
    CompileMode_Preprocess,
    CompileMode_CompileToAssembly
  };
  return values;
}

inline const char * const *EnumNamesCompileMode() {
  static const char * const names[5] = {
    "CompileToObj",
    "CompileAndLink",
    "Preprocess",
    "CompileToAssembly",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompileMode(CompileMode e) {
  if (flatbuffers::IsOutRange(e, CompileMode_CompileToObj, CompileMode_CompileToAssembly)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompileMode()[index];
}

enum CompilerToHost : uint8_t {
  CompilerToHost_NONE = 0,
  CompilerToHost_CompilerInfo = 1,
  CompilerToHost_CompileStatus = 2,
  CompilerToHost_OpenRequest = 3,
  CompilerToHost_StatRequest = 4,
  CompilerToHost_MIN = CompilerToHost_NONE,
  CompilerToHost_MAX = CompilerToHost_StatRequest
};

inline const CompilerToHost (&EnumValuesCompilerToHost())[5] {
  static const CompilerToHost values[] = {
    CompilerToHost_NONE,
    CompilerToHost_CompilerInfo,
    CompilerToHost_CompileStatus,
    CompilerToHost_OpenRequest,
    CompilerToHost_StatRequest
  };
  return values;
}

inline const char * const *EnumNamesCompilerToHost() {
  static const char * const names[6] = {
    "NONE",
    "CompilerInfo",
    "CompileStatus",
    "OpenRequest",
    "StatRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompilerToHost(CompilerToHost e) {
  if (flatbuffers::IsOutRange(e, CompilerToHost_NONE, CompilerToHost_StatRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCompilerToHost()[index];
}

template<typename T> struct CompilerToHostTraits {
  static const CompilerToHost enum_value = CompilerToHost_NONE;
};

template<> struct CompilerToHostTraits<compiler::CompilerInfo> {
  static const CompilerToHost enum_value = CompilerToHost_CompilerInfo;
};

template<> struct CompilerToHostTraits<compiler::CompileStatus> {
  static const CompilerToHost enum_value = CompilerToHost_CompileStatus;
};

template<> struct CompilerToHostTraits<compiler::OpenRequest> {
  static const CompilerToHost enum_value = CompilerToHost_OpenRequest;
};

template<> struct CompilerToHostTraits<compiler::StatRequest> {
  static const CompilerToHost enum_value = CompilerToHost_StatRequest;
};

bool VerifyCompilerToHost(flatbuffers::Verifier &verifier, const void *obj, CompilerToHost type);
bool VerifyCompilerToHostVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum HostToCompiler : uint8_t {
  HostToCompiler_NONE = 0,
  HostToCompiler_CompileRequest = 1,
  HostToCompiler_OpenResponse = 2,
  HostToCompiler_StatResponse = 3,
  HostToCompiler_Exit = 4,
  HostToCompiler_MIN = HostToCompiler_NONE,
  HostToCompiler_MAX = HostToCompiler_Exit
};

inline const HostToCompiler (&EnumValuesHostToCompiler())[5] {
  static const HostToCompiler values[] = {
    HostToCompiler_NONE,
    HostToCompiler_CompileRequest,
    HostToCompiler_OpenResponse,
    HostToCompiler_StatResponse,
    HostToCompiler_Exit
  };
  return values;
}

inline const char * const *EnumNamesHostToCompiler() {
  static const char * const names[6] = {
    "NONE",
    "CompileRequest",
    "OpenResponse",
    "StatResponse",
    "Exit",
    nullptr
  };
  return names;
}

inline const char *EnumNameHostToCompiler(HostToCompiler e) {
  if (flatbuffers::IsOutRange(e, HostToCompiler_NONE, HostToCompiler_Exit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHostToCompiler()[index];
}

template<typename T> struct HostToCompilerTraits {
  static const HostToCompiler enum_value = HostToCompiler_NONE;
};

template<> struct HostToCompilerTraits<compiler::CompileRequest> {
  static const HostToCompiler enum_value = HostToCompiler_CompileRequest;
};

template<> struct HostToCompilerTraits<compiler::OpenResponse> {
  static const HostToCompiler enum_value = HostToCompiler_OpenResponse;
};

template<> struct HostToCompilerTraits<compiler::StatResponse> {
  static const HostToCompiler enum_value = HostToCompiler_StatResponse;
};

template<> struct HostToCompilerTraits<compiler::Exit> {
  static const HostToCompiler enum_value = HostToCompiler_Exit;
};

bool VerifyHostToCompiler(flatbuffers::Verifier &verifier, const void *obj, HostToCompiler type);
bool VerifyHostToCompilerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct FileContents FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileContentsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CANONICAL_FILENAME = 4,
    VT_RAW_CONTENTS = 6,
    VT_HANDLE = 8,
    VT_HANDLE_OFFSET = 10,
    VT_SIZE = 12,
    VT_UUID = 14
  };
  const flatbuffers::String *canonical_filename() const {
    return GetPointer<const flatbuffers::String *>(VT_CANONICAL_FILENAME);
  }
  const flatbuffers::String *raw_contents() const {
    return GetPointer<const flatbuffers::String *>(VT_RAW_CONTENTS);
  }
  uint32_t handle() const {
    return GetField<uint32_t>(VT_HANDLE, 0);
  }
  uint64_t handle_offset() const {
    return GetField<uint64_t>(VT_HANDLE_OFFSET, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  uint64_t uuid() const {
    return GetField<uint64_t>(VT_UUID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CANONICAL_FILENAME) &&
           verifier.VerifyString(canonical_filename()) &&
           VerifyOffset(verifier, VT_RAW_CONTENTS) &&
           verifier.VerifyString(raw_contents()) &&
           VerifyField<uint32_t>(verifier, VT_HANDLE) &&
           VerifyField<uint64_t>(verifier, VT_HANDLE_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_UUID) &&
           verifier.EndTable();
  }
};

struct FileContentsBuilder {
  typedef FileContents Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_canonical_filename(flatbuffers::Offset<flatbuffers::String> canonical_filename) {
    fbb_.AddOffset(FileContents::VT_CANONICAL_FILENAME, canonical_filename);
  }
  void add_raw_contents(flatbuffers::Offset<flatbuffers::String> raw_contents) {
    fbb_.AddOffset(FileContents::VT_RAW_CONTENTS, raw_contents);
  }
  void add_handle(uint32_t handle) {
    fbb_.AddElement<uint32_t>(FileContents::VT_HANDLE, handle, 0);
  }
  void add_handle_offset(uint64_t handle_offset) {
    fbb_.AddElement<uint64_t>(FileContents::VT_HANDLE_OFFSET, handle_offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(FileContents::VT_SIZE, size, 0);
  }
  void add_uuid(uint64_t uuid) {
    fbb_.AddElement<uint64_t>(FileContents::VT_UUID, uuid, 0);
  }
  explicit FileContentsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileContents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileContents>(end);
    fbb_.Required(o, FileContents::VT_CANONICAL_FILENAME);
    return o;
  }
};

inline flatbuffers::Offset<FileContents> CreateFileContents(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> canonical_filename = 0,
    flatbuffers::Offset<flatbuffers::String> raw_contents = 0,
    uint32_t handle = 0,
    uint64_t handle_offset = 0,
    uint64_t size = 0,
    uint64_t uuid = 0) {
  FileContentsBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_size(size);
  builder_.add_handle_offset(handle_offset);
  builder_.add_handle(handle);
  builder_.add_raw_contents(raw_contents);
  builder_.add_canonical_filename(canonical_filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileContents> CreateFileContentsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *canonical_filename = nullptr,
    const char *raw_contents = nullptr,
    uint32_t handle = 0,
    uint64_t handle_offset = 0,
    uint64_t size = 0,
    uint64_t uuid = 0) {
  auto canonical_filename__ = canonical_filename ? _fbb.CreateString(canonical_filename) : 0;
  auto raw_contents__ = raw_contents ? _fbb.CreateString(raw_contents) : 0;
  return compiler::CreateFileContents(
      _fbb,
      canonical_filename__,
      raw_contents__,
      handle,
      handle_offset,
      size,
      uuid);
}

struct OpenRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpenRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPILE = 4,
    VT_PATH = 6,
    VT_WRITE = 8,
    VT_CREATE = 10
  };
  uint32_t compile() const {
    return GetField<uint32_t>(VT_COMPILE, 0);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool write() const {
    return GetField<uint8_t>(VT_WRITE, 0) != 0;
  }
  bool create() const {
    return GetField<uint8_t>(VT_CREATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COMPILE) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<uint8_t>(verifier, VT_WRITE) &&
           VerifyField<uint8_t>(verifier, VT_CREATE) &&
           verifier.EndTable();
  }
};

struct OpenRequestBuilder {
  typedef OpenRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_compile(uint32_t compile) {
    fbb_.AddElement<uint32_t>(OpenRequest::VT_COMPILE, compile, 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(OpenRequest::VT_PATH, path);
  }
  void add_write(bool write) {
    fbb_.AddElement<uint8_t>(OpenRequest::VT_WRITE, static_cast<uint8_t>(write), 0);
  }
  void add_create(bool create) {
    fbb_.AddElement<uint8_t>(OpenRequest::VT_CREATE, static_cast<uint8_t>(create), 0);
  }
  explicit OpenRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpenRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpenRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenRequest> CreateOpenRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t compile = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    bool write = false,
    bool create = false) {
  OpenRequestBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_compile(compile);
  builder_.add_create(create);
  builder_.add_write(write);
  return builder_.Finish();
}

inline flatbuffers::Offset<OpenRequest> CreateOpenRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t compile = 0,
    const char *path = nullptr,
    bool write = false,
    bool create = false) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return compiler::CreateOpenRequest(
      _fbb,
      compile,
      path__,
      write,
      create);
}

struct OpenResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpenResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPILE = 4,
    VT_FILE = 6,
    VT_ACCESS_ERROR = 8
  };
  uint32_t compile() const {
    return GetField<uint32_t>(VT_COMPILE, 0);
  }
  const compiler::FileContents *file() const {
    return GetPointer<const compiler::FileContents *>(VT_FILE);
  }
  compiler::FileError access_error() const {
    return static_cast<compiler::FileError>(GetField<uint16_t>(VT_ACCESS_ERROR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COMPILE) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyTable(file()) &&
           VerifyField<uint16_t>(verifier, VT_ACCESS_ERROR) &&
           verifier.EndTable();
  }
};

struct OpenResponseBuilder {
  typedef OpenResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_compile(uint32_t compile) {
    fbb_.AddElement<uint32_t>(OpenResponse::VT_COMPILE, compile, 0);
  }
  void add_file(flatbuffers::Offset<compiler::FileContents> file) {
    fbb_.AddOffset(OpenResponse::VT_FILE, file);
  }
  void add_access_error(compiler::FileError access_error) {
    fbb_.AddElement<uint16_t>(OpenResponse::VT_ACCESS_ERROR, static_cast<uint16_t>(access_error), 0);
  }
  explicit OpenResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OpenResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OpenResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<OpenResponse> CreateOpenResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t compile = 0,
    flatbuffers::Offset<compiler::FileContents> file = 0,
    compiler::FileError access_error = compiler::FileError_None) {
  OpenResponseBuilder builder_(_fbb);
  builder_.add_file(file);
  builder_.add_compile(compile);
  builder_.add_access_error(access_error);
  return builder_.Finish();
}

struct StatRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPILE = 4,
    VT_PATH = 6
  };
  uint32_t compile() const {
    return GetField<uint32_t>(VT_COMPILE, 0);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COMPILE) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct StatRequestBuilder {
  typedef StatRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_compile(uint32_t compile) {
    fbb_.AddElement<uint32_t>(StatRequest::VT_COMPILE, compile, 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(StatRequest::VT_PATH, path);
  }
  explicit StatRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatRequest> CreateStatRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t compile = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0) {
  StatRequestBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_compile(compile);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatRequest> CreateStatRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t compile = 0,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return compiler::CreateStatRequest(
      _fbb,
      compile,
      path__);
}

struct StatResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXISTS = 4,
    VT_IS_DIR = 6,
    VT_WRITE = 8,
    VT_SIZE = 10,
    VT_UUID = 12,
    VT_ERR = 14
  };
  bool exists() const {
    return GetField<uint8_t>(VT_EXISTS, 0) != 0;
  }
  bool is_dir() const {
    return GetField<uint8_t>(VT_IS_DIR, 0) != 0;
  }
  bool write() const {
    return GetField<uint8_t>(VT_WRITE, 0) != 0;
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  uint64_t uuid() const {
    return GetField<uint64_t>(VT_UUID, 0);
  }
  compiler::FileError err() const {
    return static_cast<compiler::FileError>(GetField<uint16_t>(VT_ERR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXISTS) &&
           VerifyField<uint8_t>(verifier, VT_IS_DIR) &&
           VerifyField<uint8_t>(verifier, VT_WRITE) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_UUID) &&
           VerifyField<uint16_t>(verifier, VT_ERR) &&
           verifier.EndTable();
  }
};

struct StatResponseBuilder {
  typedef StatResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exists(bool exists) {
    fbb_.AddElement<uint8_t>(StatResponse::VT_EXISTS, static_cast<uint8_t>(exists), 0);
  }
  void add_is_dir(bool is_dir) {
    fbb_.AddElement<uint8_t>(StatResponse::VT_IS_DIR, static_cast<uint8_t>(is_dir), 0);
  }
  void add_write(bool write) {
    fbb_.AddElement<uint8_t>(StatResponse::VT_WRITE, static_cast<uint8_t>(write), 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(StatResponse::VT_SIZE, size, 0);
  }
  void add_uuid(uint64_t uuid) {
    fbb_.AddElement<uint64_t>(StatResponse::VT_UUID, uuid, 0);
  }
  void add_err(compiler::FileError err) {
    fbb_.AddElement<uint16_t>(StatResponse::VT_ERR, static_cast<uint16_t>(err), 0);
  }
  explicit StatResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatResponse> CreateStatResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exists = false,
    bool is_dir = false,
    bool write = false,
    uint64_t size = 0,
    uint64_t uuid = 0,
    compiler::FileError err = compiler::FileError_None) {
  StatResponseBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_size(size);
  builder_.add_err(err);
  builder_.add_write(write);
  builder_.add_is_dir(is_dir);
  builder_.add_exists(exists);
  return builder_.Finish();
}

struct CompileSourceFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompileSourceFileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CANONICAL_PATH = 4,
    VT_OBJ_PATH = 6,
    VT_COMPILE = 8,
    VT_LINK = 10
  };
  const flatbuffers::String *canonical_path() const {
    return GetPointer<const flatbuffers::String *>(VT_CANONICAL_PATH);
  }
  const flatbuffers::String *obj_path() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJ_PATH);
  }
  bool compile() const {
    return GetField<uint8_t>(VT_COMPILE, 0) != 0;
  }
  bool link() const {
    return GetField<uint8_t>(VT_LINK, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CANONICAL_PATH) &&
           verifier.VerifyString(canonical_path()) &&
           VerifyOffset(verifier, VT_OBJ_PATH) &&
           verifier.VerifyString(obj_path()) &&
           VerifyField<uint8_t>(verifier, VT_COMPILE) &&
           VerifyField<uint8_t>(verifier, VT_LINK) &&
           verifier.EndTable();
  }
};

struct CompileSourceFileBuilder {
  typedef CompileSourceFile Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_canonical_path(flatbuffers::Offset<flatbuffers::String> canonical_path) {
    fbb_.AddOffset(CompileSourceFile::VT_CANONICAL_PATH, canonical_path);
  }
  void add_obj_path(flatbuffers::Offset<flatbuffers::String> obj_path) {
    fbb_.AddOffset(CompileSourceFile::VT_OBJ_PATH, obj_path);
  }
  void add_compile(bool compile) {
    fbb_.AddElement<uint8_t>(CompileSourceFile::VT_COMPILE, static_cast<uint8_t>(compile), 0);
  }
  void add_link(bool link) {
    fbb_.AddElement<uint8_t>(CompileSourceFile::VT_LINK, static_cast<uint8_t>(link), 0);
  }
  explicit CompileSourceFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompileSourceFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompileSourceFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompileSourceFile> CreateCompileSourceFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> canonical_path = 0,
    flatbuffers::Offset<flatbuffers::String> obj_path = 0,
    bool compile = false,
    bool link = false) {
  CompileSourceFileBuilder builder_(_fbb);
  builder_.add_obj_path(obj_path);
  builder_.add_canonical_path(canonical_path);
  builder_.add_link(link);
  builder_.add_compile(compile);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompileSourceFile> CreateCompileSourceFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *canonical_path = nullptr,
    const char *obj_path = nullptr,
    bool compile = false,
    bool link = false) {
  auto canonical_path__ = canonical_path ? _fbb.CreateString(canonical_path) : 0;
  auto obj_path__ = obj_path ? _fbb.CreateString(obj_path) : 0;
  return compiler::CreateCompileSourceFile(
      _fbb,
      canonical_path__,
      obj_path__,
      compile,
      link);
}

struct CompileRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompileRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPILE_OPTIONS = 4,
    VT_LINK_OPTIONS = 6,
    VT_LATE_LINK_OPTIONS = 8,
    VT_SOURCES = 10,
    VT_MODE = 12,
    VT_ID = 14,
    VT_CWD = 16,
    VT_OUTPUT_BINARY = 18,
    VT_SYSTEM_INCLUDES = 20,
    VT_USER_INCLUDES = 22
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *compile_options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COMPILE_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *link_options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LINK_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *late_link_options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LATE_LINK_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<compiler::CompileSourceFile>> *sources() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<compiler::CompileSourceFile>> *>(VT_SOURCES);
  }
  compiler::CompileMode mode() const {
    return static_cast<compiler::CompileMode>(GetField<uint16_t>(VT_MODE, 0));
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *cwd() const {
    return GetPointer<const flatbuffers::String *>(VT_CWD);
  }
  const flatbuffers::String *output_binary() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT_BINARY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *system_includes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SYSTEM_INCLUDES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *user_includes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_USER_INCLUDES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMPILE_OPTIONS) &&
           verifier.VerifyVector(compile_options()) &&
           verifier.VerifyVectorOfStrings(compile_options()) &&
           VerifyOffset(verifier, VT_LINK_OPTIONS) &&
           verifier.VerifyVector(link_options()) &&
           verifier.VerifyVectorOfStrings(link_options()) &&
           VerifyOffset(verifier, VT_LATE_LINK_OPTIONS) &&
           verifier.VerifyVector(late_link_options()) &&
           verifier.VerifyVectorOfStrings(late_link_options()) &&
           VerifyOffset(verifier, VT_SOURCES) &&
           verifier.VerifyVector(sources()) &&
           verifier.VerifyVectorOfTables(sources()) &&
           VerifyField<uint16_t>(verifier, VT_MODE) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_CWD) &&
           verifier.VerifyString(cwd()) &&
           VerifyOffset(verifier, VT_OUTPUT_BINARY) &&
           verifier.VerifyString(output_binary()) &&
           VerifyOffset(verifier, VT_SYSTEM_INCLUDES) &&
           verifier.VerifyVector(system_includes()) &&
           verifier.VerifyVectorOfStrings(system_includes()) &&
           VerifyOffset(verifier, VT_USER_INCLUDES) &&
           verifier.VerifyVector(user_includes()) &&
           verifier.VerifyVectorOfStrings(user_includes()) &&
           verifier.EndTable();
  }
};

struct CompileRequestBuilder {
  typedef CompileRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_compile_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> compile_options) {
    fbb_.AddOffset(CompileRequest::VT_COMPILE_OPTIONS, compile_options);
  }
  void add_link_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> link_options) {
    fbb_.AddOffset(CompileRequest::VT_LINK_OPTIONS, link_options);
  }
  void add_late_link_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> late_link_options) {
    fbb_.AddOffset(CompileRequest::VT_LATE_LINK_OPTIONS, late_link_options);
  }
  void add_sources(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<compiler::CompileSourceFile>>> sources) {
    fbb_.AddOffset(CompileRequest::VT_SOURCES, sources);
  }
  void add_mode(compiler::CompileMode mode) {
    fbb_.AddElement<uint16_t>(CompileRequest::VT_MODE, static_cast<uint16_t>(mode), 0);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(CompileRequest::VT_ID, id, 0);
  }
  void add_cwd(flatbuffers::Offset<flatbuffers::String> cwd) {
    fbb_.AddOffset(CompileRequest::VT_CWD, cwd);
  }
  void add_output_binary(flatbuffers::Offset<flatbuffers::String> output_binary) {
    fbb_.AddOffset(CompileRequest::VT_OUTPUT_BINARY, output_binary);
  }
  void add_system_includes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> system_includes) {
    fbb_.AddOffset(CompileRequest::VT_SYSTEM_INCLUDES, system_includes);
  }
  void add_user_includes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> user_includes) {
    fbb_.AddOffset(CompileRequest::VT_USER_INCLUDES, user_includes);
  }
  explicit CompileRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompileRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompileRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompileRequest> CreateCompileRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> compile_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> link_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> late_link_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<compiler::CompileSourceFile>>> sources = 0,
    compiler::CompileMode mode = compiler::CompileMode_CompileToObj,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> cwd = 0,
    flatbuffers::Offset<flatbuffers::String> output_binary = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> system_includes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> user_includes = 0) {
  CompileRequestBuilder builder_(_fbb);
  builder_.add_user_includes(user_includes);
  builder_.add_system_includes(system_includes);
  builder_.add_output_binary(output_binary);
  builder_.add_cwd(cwd);
  builder_.add_id(id);
  builder_.add_sources(sources);
  builder_.add_late_link_options(late_link_options);
  builder_.add_link_options(link_options);
  builder_.add_compile_options(compile_options);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompileRequest> CreateCompileRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *compile_options = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *link_options = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *late_link_options = nullptr,
    const std::vector<flatbuffers::Offset<compiler::CompileSourceFile>> *sources = nullptr,
    compiler::CompileMode mode = compiler::CompileMode_CompileToObj,
    uint32_t id = 0,
    const char *cwd = nullptr,
    const char *output_binary = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *system_includes = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *user_includes = nullptr) {
  auto compile_options__ = compile_options ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*compile_options) : 0;
  auto link_options__ = link_options ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*link_options) : 0;
  auto late_link_options__ = late_link_options ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*late_link_options) : 0;
  auto sources__ = sources ? _fbb.CreateVector<flatbuffers::Offset<compiler::CompileSourceFile>>(*sources) : 0;
  auto cwd__ = cwd ? _fbb.CreateString(cwd) : 0;
  auto output_binary__ = output_binary ? _fbb.CreateString(output_binary) : 0;
  auto system_includes__ = system_includes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*system_includes) : 0;
  auto user_includes__ = user_includes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*user_includes) : 0;
  return compiler::CreateCompileRequest(
      _fbb,
      compile_options__,
      link_options__,
      late_link_options__,
      sources__,
      mode,
      id,
      cwd__,
      output_binary__,
      system_includes__,
      user_includes__);
}

struct CompileStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompileStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_STATUS = 6,
    VT_ERRORED_STATE = 8,
    VT_OUTPUT = 10
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool status() const {
    return GetField<uint8_t>(VT_STATUS, 0) != 0;
  }
  const flatbuffers::String *errored_state() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRORED_STATE);
  }
  const flatbuffers::String *output() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_STATUS) &&
           VerifyOffset(verifier, VT_ERRORED_STATE) &&
           verifier.VerifyString(errored_state()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyString(output()) &&
           verifier.EndTable();
  }
};

struct CompileStatusBuilder {
  typedef CompileStatus Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(CompileStatus::VT_ID, id, 0);
  }
  void add_status(bool status) {
    fbb_.AddElement<uint8_t>(CompileStatus::VT_STATUS, static_cast<uint8_t>(status), 0);
  }
  void add_errored_state(flatbuffers::Offset<flatbuffers::String> errored_state) {
    fbb_.AddOffset(CompileStatus::VT_ERRORED_STATE, errored_state);
  }
  void add_output(flatbuffers::Offset<flatbuffers::String> output) {
    fbb_.AddOffset(CompileStatus::VT_OUTPUT, output);
  }
  explicit CompileStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompileStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompileStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompileStatus> CreateCompileStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool status = false,
    flatbuffers::Offset<flatbuffers::String> errored_state = 0,
    flatbuffers::Offset<flatbuffers::String> output = 0) {
  CompileStatusBuilder builder_(_fbb);
  builder_.add_output(output);
  builder_.add_errored_state(errored_state);
  builder_.add_id(id);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompileStatus> CreateCompileStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    bool status = false,
    const char *errored_state = nullptr,
    const char *output = nullptr) {
  auto errored_state__ = errored_state ? _fbb.CreateString(errored_state) : 0;
  auto output__ = output ? _fbb.CreateString(output) : 0;
  return compiler::CreateCompileStatus(
      _fbb,
      id,
      status,
      errored_state__,
      output__);
}

struct Exit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExitBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExitBuilder {
  typedef Exit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Exit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exit> CreateExit(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExitBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CompilerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompilerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_DEFAULT_TARGET = 6,
    VT_HOST_CPU = 8,
    VT_PACKAGE = 10,
    VT_TARGETS = 12
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::String *default_target() const {
    return GetPointer<const flatbuffers::String *>(VT_DEFAULT_TARGET);
  }
  const flatbuffers::String *host_cpu() const {
    return GetPointer<const flatbuffers::String *>(VT_HOST_CPU);
  }
  const flatbuffers::String *package() const {
    return GetPointer<const flatbuffers::String *>(VT_PACKAGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TARGETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_DEFAULT_TARGET) &&
           verifier.VerifyString(default_target()) &&
           VerifyOffset(verifier, VT_HOST_CPU) &&
           verifier.VerifyString(host_cpu()) &&
           VerifyOffset(verifier, VT_PACKAGE) &&
           verifier.VerifyString(package()) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.VerifyVector(targets()) &&
           verifier.VerifyVectorOfStrings(targets()) &&
           verifier.EndTable();
  }
};

struct CompilerInfoBuilder {
  typedef CompilerInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(CompilerInfo::VT_VERSION, version, 0);
  }
  void add_default_target(flatbuffers::Offset<flatbuffers::String> default_target) {
    fbb_.AddOffset(CompilerInfo::VT_DEFAULT_TARGET, default_target);
  }
  void add_host_cpu(flatbuffers::Offset<flatbuffers::String> host_cpu) {
    fbb_.AddOffset(CompilerInfo::VT_HOST_CPU, host_cpu);
  }
  void add_package(flatbuffers::Offset<flatbuffers::String> package) {
    fbb_.AddOffset(CompilerInfo::VT_PACKAGE, package);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets) {
    fbb_.AddOffset(CompilerInfo::VT_TARGETS, targets);
  }
  explicit CompilerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompilerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompilerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompilerInfo> CreateCompilerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> default_target = 0,
    flatbuffers::Offset<flatbuffers::String> host_cpu = 0,
    flatbuffers::Offset<flatbuffers::String> package = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> targets = 0) {
  CompilerInfoBuilder builder_(_fbb);
  builder_.add_targets(targets);
  builder_.add_package(package);
  builder_.add_host_cpu(host_cpu);
  builder_.add_default_target(default_target);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompilerInfo> CreateCompilerInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const char *default_target = nullptr,
    const char *host_cpu = nullptr,
    const char *package = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *targets = nullptr) {
  auto default_target__ = default_target ? _fbb.CreateString(default_target) : 0;
  auto host_cpu__ = host_cpu ? _fbb.CreateString(host_cpu) : 0;
  auto package__ = package ? _fbb.CreateString(package) : 0;
  auto targets__ = targets ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*targets) : 0;
  return compiler::CreateCompilerInfo(
      _fbb,
      version,
      default_target__,
      host_cpu__,
      package__,
      targets__);
}

struct CompilerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompilerMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  compiler::CompilerToHost msg_type() const {
    return static_cast<compiler::CompilerToHost>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const compiler::CompilerInfo *msg_as_CompilerInfo() const {
    return msg_type() == compiler::CompilerToHost_CompilerInfo ? static_cast<const compiler::CompilerInfo *>(msg()) : nullptr;
  }
  const compiler::CompileStatus *msg_as_CompileStatus() const {
    return msg_type() == compiler::CompilerToHost_CompileStatus ? static_cast<const compiler::CompileStatus *>(msg()) : nullptr;
  }
  const compiler::OpenRequest *msg_as_OpenRequest() const {
    return msg_type() == compiler::CompilerToHost_OpenRequest ? static_cast<const compiler::OpenRequest *>(msg()) : nullptr;
  }
  const compiler::StatRequest *msg_as_StatRequest() const {
    return msg_type() == compiler::CompilerToHost_StatRequest ? static_cast<const compiler::StatRequest *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyCompilerToHost(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const compiler::CompilerInfo *CompilerMessage::msg_as<compiler::CompilerInfo>() const {
  return msg_as_CompilerInfo();
}

template<> inline const compiler::CompileStatus *CompilerMessage::msg_as<compiler::CompileStatus>() const {
  return msg_as_CompileStatus();
}

template<> inline const compiler::OpenRequest *CompilerMessage::msg_as<compiler::OpenRequest>() const {
  return msg_as_OpenRequest();
}

template<> inline const compiler::StatRequest *CompilerMessage::msg_as<compiler::StatRequest>() const {
  return msg_as_StatRequest();
}

struct CompilerMessageBuilder {
  typedef CompilerMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(compiler::CompilerToHost msg_type) {
    fbb_.AddElement<uint8_t>(CompilerMessage::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(CompilerMessage::VT_MSG, msg);
  }
  explicit CompilerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompilerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompilerMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompilerMessage> CreateCompilerMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    compiler::CompilerToHost msg_type = compiler::CompilerToHost_NONE,
    flatbuffers::Offset<void> msg = 0) {
  CompilerMessageBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

struct HostMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  compiler::HostToCompiler msg_type() const {
    return static_cast<compiler::HostToCompiler>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const compiler::CompileRequest *msg_as_CompileRequest() const {
    return msg_type() == compiler::HostToCompiler_CompileRequest ? static_cast<const compiler::CompileRequest *>(msg()) : nullptr;
  }
  const compiler::OpenResponse *msg_as_OpenResponse() const {
    return msg_type() == compiler::HostToCompiler_OpenResponse ? static_cast<const compiler::OpenResponse *>(msg()) : nullptr;
  }
  const compiler::StatResponse *msg_as_StatResponse() const {
    return msg_type() == compiler::HostToCompiler_StatResponse ? static_cast<const compiler::StatResponse *>(msg()) : nullptr;
  }
  const compiler::Exit *msg_as_Exit() const {
    return msg_type() == compiler::HostToCompiler_Exit ? static_cast<const compiler::Exit *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyHostToCompiler(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const compiler::CompileRequest *HostMessage::msg_as<compiler::CompileRequest>() const {
  return msg_as_CompileRequest();
}

template<> inline const compiler::OpenResponse *HostMessage::msg_as<compiler::OpenResponse>() const {
  return msg_as_OpenResponse();
}

template<> inline const compiler::StatResponse *HostMessage::msg_as<compiler::StatResponse>() const {
  return msg_as_StatResponse();
}

template<> inline const compiler::Exit *HostMessage::msg_as<compiler::Exit>() const {
  return msg_as_Exit();
}

struct HostMessageBuilder {
  typedef HostMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(compiler::HostToCompiler msg_type) {
    fbb_.AddElement<uint8_t>(HostMessage::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(HostMessage::VT_MSG, msg);
  }
  explicit HostMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HostMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostMessage> CreateHostMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    compiler::HostToCompiler msg_type = compiler::HostToCompiler_NONE,
    flatbuffers::Offset<void> msg = 0) {
  HostMessageBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

inline bool VerifyCompilerToHost(flatbuffers::Verifier &verifier, const void *obj, CompilerToHost type) {
  switch (type) {
    case CompilerToHost_NONE: {
      return true;
    }
    case CompilerToHost_CompilerInfo: {
      auto ptr = reinterpret_cast<const compiler::CompilerInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompilerToHost_CompileStatus: {
      auto ptr = reinterpret_cast<const compiler::CompileStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompilerToHost_OpenRequest: {
      auto ptr = reinterpret_cast<const compiler::OpenRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CompilerToHost_StatRequest: {
      auto ptr = reinterpret_cast<const compiler::StatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCompilerToHostVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCompilerToHost(
        verifier,  values->Get(i), types->GetEnum<CompilerToHost>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyHostToCompiler(flatbuffers::Verifier &verifier, const void *obj, HostToCompiler type) {
  switch (type) {
    case HostToCompiler_NONE: {
      return true;
    }
    case HostToCompiler_CompileRequest: {
      auto ptr = reinterpret_cast<const compiler::CompileRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostToCompiler_OpenResponse: {
      auto ptr = reinterpret_cast<const compiler::OpenResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostToCompiler_StatResponse: {
      auto ptr = reinterpret_cast<const compiler::StatResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostToCompiler_Exit: {
      auto ptr = reinterpret_cast<const compiler::Exit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHostToCompilerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHostToCompiler(
        verifier,  values->Get(i), types->GetEnum<HostToCompiler>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace compiler

#endif  // FLATBUFFERS_GENERATED_COMPILE_COMPILER_H_
